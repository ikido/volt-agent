"""Data models for Fibery entities and users"""

from typing import Dict, Any, List, Optional
from datetime import datetime


class FiberyUser:
    """Represents a Fibery workspace user"""
    
    def __init__(self, data: Dict[str, Any]):
        """Initialize from API response
        
        Args:
            data: User data from Fibery API
        """
        self.fibery_id = data.get('fibery/id')
        self.email = data.get('user/email') or data.get('email')
        self.name = data.get('user/name') or data.get('name')
        self.role = data.get('user/role') or data.get('role')
        self.is_active = data.get('fibery/active', True)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for database storage
        
        Returns:
            Dictionary representation
        """
        return {
            'fibery_id': self.fibery_id,
            'email': self.email,
            'name': self.name,
            'role': self.role,
            'is_active': self.is_active
        }


class FiberyEntity:
    """Represents a Fibery entity (Task, Bug, Feature, etc.)"""
    
    def __init__(self, data: Dict[str, Any], entity_type: str):
        """Initialize from API response
        
        Args:
            data: Entity data from Fibery API
            entity_type: Entity type (e.g., "Scrum/Task")
        """
        self.fibery_id = data.get('id')
        self.public_id = data.get('publicId')
        self.entity_type = entity_type
        self.entity_name = data.get('name', '')
        self.description_md = self._extract_description(data)
        self.comments = self._extract_comments(data)
        self.metadata = self._extract_metadata(data)
        self.summary_md = None  # Will be generated by LLM
    
    def _extract_description(self, data: Dict[str, Any]) -> Optional[str]:
        """Extract description from entity data
        
        Args:
            data: Entity data
            
        Returns:
            Description as markdown or None
        """
        desc = data.get('description')
        if isinstance(desc, dict):
            # Rich text field - extract markdown
            # Try 'md' first (most common), then 'text', then 'html'
            return desc.get('md') or desc.get('text') or desc.get('html')
        elif isinstance(desc, str):
            return desc
        return None
    
    def _extract_comments(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract comments from entity data
        
        Args:
            data: Entity data
            
        Returns:
            List of comment dictionaries
        """
        comments = data.get('comments', [])
        if not comments:
            return []
        
        # Process comments into nested structure
        processed = []
        for comment in comments:
            processed.append({
                'id': comment.get('id'),
                'author_name': self._get_nested(comment, 'author.name'),
                'author_email': self._get_nested(comment, 'author.email'),
                'body': comment.get('body'),
                'created_at': comment.get('createdAt') or comment.get('created_at'),
                'replies': comment.get('replies', [])
            })
        
        return processed
    
    def _extract_metadata(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract metadata from entity data
        
        Args:
            data: Entity data
            
        Returns:
            Metadata dictionary
        """
        metadata = {}
        
        # State
        if 'state' in data:
            state = data['state']
            if isinstance(state, dict):
                metadata['state'] = {'name': state.get('name')}
            else:
                metadata['state'] = {'name': str(state)}
        
        # Dates
        dates = {}
        date_fields = [
            'completionDate', 'completedDate', 'startedDate', 'plannedStart', 'plannedEnd',
            'actualReleaseDate', 'plannedReleaseDate', 'deploymentDate',
            'creationDate', 'modificationDate',
            # Feature-specific dates
            'devActualStartDate', 'devPlannedEndDate', 'devActualEndDate'
        ]
        for field in date_fields:
            if field in data and data[field]:
                dates[field] = data[field]
        if dates:
            metadata['dates'] = dates
        
        # Calculate overdue status (check both task and feature date fields)
        metadata['is_overdue'] = False
        metadata['overdue_days'] = 0
        
        # Try Feature-specific field first, then fall back to task field
        planned_end_str = dates.get('devPlannedEndDate') or dates.get('plannedEnd')
        completion_date_str = dates.get('devActualEndDate') or dates.get('completionDate') or dates.get('completedDate')
        
        if planned_end_str:
            try:
                planned_end = datetime.fromisoformat(planned_end_str.replace('Z', '+00:00'))
                today = datetime.now(planned_end.tzinfo) if planned_end.tzinfo else datetime.now()
                
                # Only mark as overdue if not completed
                is_completed = bool(completion_date_str)
                
                if not is_completed and today > planned_end:
                    metadata['is_overdue'] = True
                    metadata['overdue_days'] = (today - planned_end).days
            except (ValueError, TypeError) as e:
                # If date parsing fails, log but continue
                pass
        
        # Relations (feature, parent entities, etc.)
        relations = {}
        relation_fields = [
            'feature', 'task', 'bug', 'designFeature', 'epic', 'sprint',
            'parentTask', 'parentBug', 'scrumFeatures'
        ]
        for field in relation_fields:
            if field in data and data[field]:
                relations[field] = self._extract_relation(data[field])
        if relations:
            metadata['relations'] = relations
        
        # Collections (tasks, bugs, features, etc.)
        collections = {}
        collection_fields = [
            'tasks', 'bugs', 'features', 'requests', 'workVersions', 
            'assignees', 'assignedUser'
        ]
        for field in collection_fields:
            if field in data and data[field]:
                value = data[field]
                if isinstance(value, list):
                    collections[field] = [self._extract_relation(item) for item in value]
                else:
                    collections[field] = self._extract_relation(value)
        if collections:
            metadata['collections'] = collections
        
        # Custom fields (severity, priority, urgency, etc.)
        custom = {}
        custom_fields = [
            'severity', 'priority', 'urgency', 'effort', 'reviewOutcome',
            # Time tracking fields
            'timeSpentH', 'tasksTimeSpent', 'featureTimeSpentH'
        ]
        for field in custom_fields:
            if field in data and data[field]:
                value = data[field]
                if isinstance(value, dict):
                    custom[field] = value.get('name', str(value))
                else:
                    custom[field] = value
        if custom:
            metadata['custom_fields'] = custom
        
        return metadata
    
    def _extract_relation(self, relation_data: Any) -> Optional[Dict[str, Any]]:
        """Extract relation data
        
        Args:
            relation_data: Relation object or list
            
        Returns:
            Simplified relation dictionary or None
        """
        if not relation_data:
            return None
        
        if isinstance(relation_data, dict):
            # Start with core fields
            result = {
                'publicId': relation_data.get('publicId'),
                'name': relation_data.get('name'),
            }
            
            # Extract state (could be dict or string)
            if 'state' in relation_data:
                state_val = relation_data.get('state')
                if isinstance(state_val, dict):
                    result['state'] = state_val.get('name')
                else:
                    result['state'] = state_val
            
            # Preserve additional fields (dates, time, assignees, etc.)
            extra_fields = ['completionDate', 'startedDate', 'plannedEnd', 'plannedStart', 
                           'timeSpentH', 'assignees']
            for field in extra_fields:
                if field in relation_data:
                    result[field] = relation_data[field]
            
            return result
        
        return None
    
    def _get_nested(self, data: Dict[str, Any], path: str) -> Optional[str]:
        """Get nested value from dictionary using dot notation
        
        Args:
            data: Dictionary to search
            path: Dot-separated path (e.g., "author.name")
            
        Returns:
            Value or None
        """
        keys = path.split('.')
        value = data
        for key in keys:
            if isinstance(value, dict):
                value = value.get(key)
            else:
                return None
        return value
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for database storage
        
        Returns:
            Dictionary representation
        """
        return {
            'fibery_id': self.fibery_id,
            'public_id': self.public_id,
            'entity_type': self.entity_type,
            'entity_name': self.entity_name,
            'description_md': self.description_md,
            'comments': self.comments,
            'metadata': self.metadata,
            'summary_md': self.summary_md
        }

